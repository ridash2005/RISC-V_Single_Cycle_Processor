

### RISC-V Single-Cycle Processor (32 bit)


## Overview

This project implements a complete RISC-V single-cycle processor core
using Register Transfer Level (RTL) design principles. The processor
executes one full instruction per clock cycle, meaning that instruction
fetch, decode, execute, memory access, and write-back all occur within
a single rising clock edge.

The design is intentionally non-pipelined to emphasize clarity of
datapath behavior, control signal generation, and instruction-level
hardware understanding. This architecture is widely used in academic
contexts to introduce CPU design concepts before moving to pipelined
or out-of-order processors.

The processor follows the RV32I base integer instruction set and is
implemented in synthesizable Verilog, suitable for simulation and FPGA
synthesis.


# Design Philosophy

- Single-cycle execution for conceptual simplicity
- Explicit datapath separation from control logic
- Modular RTL structure for easy debugging and extension
- Instruction-driven control (opcode-based decoding)
- Clear mapping between RISC-V ISA semantics and hardware behavior


# High-Level Architecture

The processor is composed of the following major subsystems:

1. Program Counter (PC) Logic
2. Instruction Memory
3. Control Unit
4. Register File
5. Immediate Generator
6. Arithmetic Logic Unit (ALU)
7. Data Memory
8. Write-Back Selection Logic
9. Next-PC Selection Logic

All of these blocks operate concurrently within a single clock cycle.


# 1. Program Counter (PC) Subsystem

The Program Counter holds the address of the currently executing
instruction. On every clock edge, the PC is updated with the address
of the next instruction.

Possible PC update sources include:
- PC + 4 (sequential execution)
- Branch target address
- Jump target address

The PC update decision is controlled by branch and jump control signals
generated by the control unit.


# 2. Instruction Memory

Instruction memory is a read-only memory block indexed by the PC.
It outputs a 32-bit instruction corresponding to the current PC value.

Key characteristics:
- Asynchronous read behavior
- Word-aligned access
- No write capability during execution

The instruction is immediately forwarded to the decode and control
logic within the same cycle.


# 3. Instruction Decode and Control Unit

The control unit interprets the instruction opcode and generates all
necessary control signals required to steer the datapath.

Control signals include:
- Register write enable
- ALU operation selection
- ALU source selection (register vs immediate)
- Memory read/write enables
- Write-back source selection
- Branch and jump control flags

This design uses a centralized control strategy where instruction
fields directly influence datapath behavior.


# 4. Register File

The register file consists of 32 general-purpose registers, each
32 bits wide, compliant with the RV32I specification.

Features:
- Two read ports (rs1, rs2)
- One write port (rd)
- Register x0 is hardwired to zero
- Write occurs on the active clock edge

The register file supplies operands to the ALU and accepts results
during the write-back stage.

# 5. Immediate Generator

The immediate generator extracts and sign-extends immediate values
from different instruction formats, including:

- I-type (loads, arithmetic immediate)
- S-type (stores)
- B-type (branches)
- J-type (jumps)
- U-type (upper immediate)

This unit ensures that all immediates are correctly aligned and
extended to 32 bits before use by the ALU.


# 6. Arithmetic Logic Unit (ALU)

The ALU performs all arithmetic and logical computations required
by the instruction set.

Supported operations typically include:
- Addition and subtraction
- Logical AND, OR, XOR
- Shift operations
- Comparison for branch decisions

The specific ALU operation is selected via ALU control signals derived
from the instruction funct fields and opcode.


# 7. Data Memory

Data memory is used exclusively by load and store instructions.

Characteristics:
- Address provided by ALU output
- Write data sourced from register file
- Read data forwarded to write-back logic
- Controlled by explicit memory enable signals

Non-memory instructions bypass this block.

# 8. Write-Back Logic

The write-back stage selects the final value written to the destination
register. Possible write-back sources include:

- ALU computation result
- Data memory read output
- PC + 4 (for jump-and-link instructions)

A multiplexer controlled by the control unit determines the correct
write-back value.


# 9. Next PC Selection Logic

Next PC selection determines program flow. It chooses between:
- Sequential execution (PC + 4)
- Conditional branch target
- Unconditional jump target

Branch decisions are made using ALU comparison results combined with
branch control signals.


# Instruction Execution in a Single Cycle

Within one clock cycle, the following operations occur in parallel:

- Instruction fetch from instruction memory
- Decode and control signal generation
- Register operand read
- ALU execution or address calculation
- Data memory access (if required)
- Write-back data selection
- Next PC computation

The clock period must be long enough to accommodate the slowest
instruction path.


# License

This project is provided for educational use. Users are free to modify,
extend, and experiment with the design for learning purposes.


# Contact 
Email    : rickaryadas@gmail.com 
 


